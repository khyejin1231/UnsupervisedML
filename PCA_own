```{r}
#help functions from Pieter Schoonees
binary_search <- function(x, c, maxit = 100) {
  
  ## Check if x already meets the condition, or whether c is zero, and return 0 in either case
  x_l1 <- sum(abs(x))
  if (x_l1 <= c || c == 0) {
    return(0)
  }
  
  ## Initialize search boundaries and iteration counter
  lo <- 0
  hi <- max(abs(x))
  i <- 0
  
  ## Iterate
  while(i < maxit) {
    
    ## Increase iteration count
    i <- i + 1
    
    ## Get mean of current bounds, and evaluate L1 norm there
    m <- lo + (hi - lo)/2
    m_l1 <- sum(abs(soft_l2norm(x, m)))
    
    ## Update either lower or upper threshold
    if (m_l1 <= c) { ## Note: must be <= otherwise lambda will be too large (as in PMA)
      hi <- m
    } else {
      lo <- m
    }
    
    ## Break if lo and hi have converged
    if (abs(lo - hi) <= sqrt(.Machine$double.eps)) {
      break
    }
  }
  
  return(lo + (hi - lo)/2)
}

#' Soft-thresholding Function
soft_thresh <- function(x, lambda) {
  sign(x) * (pmax(abs(x) - lambda, 0))
}
```


```{r cars}
library("dplyr")
#install.packages("PMA")
library("PMA")
#install.packages("tidyr")
library(tidyr)
#install.packages("DataCombine")
library("DataCombine")
#install.packages("sparsepca")
library("sparsepca")
#install.packages("PMA")
library("PMA")
#please load the data and set it to fifa
#also run 'utilities.R' file before hand.

#Read data
load("/cloud/project/FIFA2017_NL.RData")
mfifa <- subset(fifa, Position != 'Gk')
#The variables should be centered to have mean zero.
#Furthermore, the results obtained when we perform PCA will also
#depend on whether the variables have been individually scaled.
mfifa$Position <- as.numeric(as.factor(mfifa$Position)) - 1
mfifanum<- select_if(mfifa, is.numeric)
#mfifanum <- scale(mfifanum, scale = TRUE)
mfifanum$mid <- rep(0, nrow(mfifanum)) #mid
mfifanum$mid[which(mfifa$Position == 1)] <- mfifanum$mid[which(mfifa$Position == 1)]+ 1

mfifanum$def <- rep(0, nrow(mfifanum))
mfifanum$def[which(mfifa$Position == 2)] <- mfifanum$def[which(mfifa$Position == 2)]+ 1

mfifanum <- mfifanum[,-1]

X <- as.matrix(mfifanum)
X <- X[,-32]
colnames(X)
##################functions#####################
#pca

pca <- function(X){
  mcovX <- cov(X, use = "pairwise.complete.obs")
  lpca <- eigen(mcovX)
  return(list("eigen" = lpca$values, "pc" = 
                lpca$vectors))
}



#sparse pca
#rank 1
spcar1 <- function(X, c2, imax){
  
  #initialization
  X <- as.matrix(X)
  n <- nrow(X)
  p <- ncol(X)
  pca <- pca(X)
  v <- as.matrix(pca$pc[,1]) 
  vnorm <- sum(abs(v))
  i <- 0
  
  while(i < imax){
    i <- i + 1
    Xv <- X %*% v
    
    u <- Xv / as.numeric(sqrt((t(Xv) %*% Xv))) #How to deal with NAs - changes to 0?
    lambda <- binary_search(vnorm, c2, maxit = 100)
    vtXu <- t(X) %*% u
    
    st <- soft_thresh(vtXu, lambda)
    
    v <- st / sqrt(sum(st^2)) # why a number?
    vnorm <- sum(abs(v))
  }
  
  sigma <- t(u) %*% X %*% v
  
  return(list("u" = u, "v" = v, "sigma" = sigma))
}

#sparse pca higher rank
spca <- function(X, k, c2, imax){
  
  lu <- list()
  lv <- list()
  lsigma <- list()
  
  X_1 <- X
  
  for (i in 1:k){
    
    result <- spcar1(X_1, c2, imax)
    u <- result$u
    v <- result$v
    sigma <- result$sigma
    lu[i] <- list(u)
    lv[i] <- list(v)
    lsigma[i] <- list(sigma)
    
    
    X_1 <- X_1 - as.numeric(sigma) * ( u %*% t(v) )
  }
  
  
  return (list("u" = lu, "v" = lv, "sigma" = lsigma))
}


```



```{r results}
c1 <- SPC.cv(X, sumabsvs = sqrt(ncol(X)), nfolds = 10,
       niter = 5, )
icl <- c1$bestsumabsv
spca_result <- spca(X, 3, icl, 5)
spca_result$v
spca_result$u
```
